\documentclass[a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{polski}
\usepackage[cp1250]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{listings}

\newcommand{\code}[1]{{\lstinline[basicstyle=\ttfamily\color{black}] |#1| }}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}

\title{ Bezp. syst. i us³ug inform. 2\\{\huge Komunikator z szyfrowaniem} \\}
\author{Adam Zimny 209787}

\date{\today}

\begin{document}
\maketitle

\section{Cel projektu}\indent \par 
Celem projektu jest przygotowanie komunikatora w architekturze klient-serwer wspieraj¹cego bezpieczn¹ wymianê sekretu wg protoko³u Diffiego-Hellmana oraz obs³uguj¹cy zadany format komunikacji.
\section{Wymagania}

%\subsection{Protokó³ Diffiego-Hellmana}
\subsection{Protokó³ komunikacji} \indent \par \label{sec:kom}
W celu zapewnienia kompatybilnoœci z innymi realizacjami tego projektu, ustalony zosta³ protokó³ komunikacji, wed³ug którego powinna odbywaæ siê wymiana wiadomoœci w aplikacji. 
Wiadomoœci przesy³ane pomiêdzy klientem a serwerem powinny byæ zgodne z formatem danych opartych o JSON przedstawionym w tabeli \ref{kom}. W celu rozpoczêcia komunikacji klient i serwer musz¹ wymieniæ nastêpuj¹ce wiadomoœci: 
\begin{table}[h]
\begin{tabular}{|c|l|l|}
\hline
Stage & Klient & Serwer \\
\hline
1 & \{ "request"': "keys" \}  & \\
\hline
2 & &\{"p": 123, "g": 123 \} \\
\hline
3 & \{"a": 123 \}  & \{ "b": 123 \}\\
\hline
4 & \{"encryption": "none"\} & \\
\hline
5 & \{"msg": "...", "from": "John" \} & \{ "msg": "...", "from": "Anna" \}\\
\hline

\end{tabular}
\caption{Struktura wiadomoœci protoko³u komunikacyjnego aplikacji}
\label{kom}
\end{table}

Podczas wymiany wiadomoœci nale¿y uwzglêdniæ podane wymagania: 
\begin{itemize}
\item W kroku 3. wiadomoœci od serwera i klienta mog¹ nast¹piæ w dowolnej kolejnoœci.
\item Krok 4. tabeli \ref{kom} jest opcjonalny. W przypadku braku wys³ania wiadomoœci o metodzie szyfrowania nale¿y przyj¹æ wartoœæ domyœln¹ \textit{none}.
\end{itemize}

\subsection{Szyfrowanie}
Wiadomoœci przesy³ane miêdzy klientami a serwerem powinny byæ szyfrowane wed³ug metody wybranej przez u¿ytkownika.
Komunikator powinien wspiraæ nastêpuj¹ce metody szyfrowania:
\begin{itemize}
\item none - brak szyfrowania (domyœlne)
\item xor - szyfrowanie OTP xor jednobajtowe (nale¿y u¿yæ najm³odszego bajtu sekretu)
\item cezar - szyfr cezara
\end{itemize}
Komunikator powinien zapewniaæ mo¿liwoœæ zmiany metody szyfrowania w dowolnym momencie.

Treœæ wiadomoœci powinna byæ zakodowana za pomoc¹ base64 przed umieszczeniem jej w strukturze JSON:

\begin{lstlisting}
base64(encrypt(user_message)) 
\end{lstlisting}

\section{Projekt i implementacja} \indent \par
Aplikacja wykonana zosta³a w jêzyku Java w wersji 8, z wykorzystaniem technologii JavaFX oraz Swing do stworzenia interfejsów u¿ytkownika odpowiednio dla aplikacji klienckiej i serwerowej. Do implementacji projektu wykorzystane zosta³o œrodowisko programistyczne IntelliJ IDEA. Projekt zosta³ wykonany z wykorzystaniem repozytorium kodu w serwisie GitHub. 

\subsection{Koncepcja rozwi¹zania}
Czêœæ serwerowa i kliencka aplikacji zostan¹ wykonane w ramach jednego projektu, pozwalaj¹c uzytkownikowi wybraæ funkcje uruchomionego programu na pocz¹tku jego dzia³ania. Po skonfigurowaniu parametrów po³¹czenia aplikacja rozpocznie dzia³anie zale¿nie od wybranej funkcji wed³ug jednego ze schematów: 

\paragraph{Klient}
\begin{enumerate}
\item Aplikacja tworzy po³¹czenie z zadanym adresem na wskazanym porcie.
\item Po utworzeniu po³¹czenia rozpoczyna siê wymiana kluczy wed³ug protoko³u opisanego w punkcie \ref{sec:kom}.
\item Po ustaleniu kluczy szyfrowania aplikacja oczekuje na interakcjê u¿ytkownika.
\end{enumerate}

\paragraph{Serwer}
\begin{enumerate}
\item Aplikacja tworzy nowy w¹tek oczekuj¹cy na po³¹czenia.
\item Po ustanowieniu po³¹czenia z klientem serwer tworzy  dla niego w¹tek nas³uchuj¹cy i odpowiada na zapytania ze strony klienta wed³ug ustalonego protoko³u.
\item Po otrzymaniu wiadomoœci z jednego z aktywnych w¹tków klienckich, serwer odszyfrowuje wiadomoœæ wed³ug metody wybranej przez nadawcê.
\item Serwer  rozg³asza wiadomoœæ do wszystkich klientów, ponownie szyfruj¹c j¹ indywidualnie dla ka¿dego klienta w wykorzystaniem jego preferowanej metody szyfrowania.
\end{enumerate}

\subsection{Struktura projektu}
Projekt sk³ada siê z 11 klas i 2 plików deklaracji interfejsu o rozszerzeniu \textbf{.fxml} odpowiednim dla technologii JavaFX. Pliki zosta³y podzielone w pakiety wed³ug funkcjonalnoœci, jakie implementuj¹. Struktura projektu przedstawiona jest na rysunku \ref{struc}.

\begin{figure}[h]
\includegraphics[height=6cm]{projekt}
\centering
\label{struc}
\caption{Struktura plików projektu}
\end{figure}

Zawartoœæ istatniejszych pakietów i plików oraz ich funkcje w projekcie opisuje poni¿sza lista:
\begin{description}
\item [fxml] - pakiet zawieraj¹cy pliki interfejsu u¿ytkownika
\item [constant] - pakiet zawieraj¹cy definicje sta³ych dla kluczy i wartoœci u¿ywanych w protokole komunikacyjnym aplikacji 
\item [crypto] - pakiet zawieraj¹cy klasy realizuj¹ce funkcjonalnoœæ szyfrowania wiadomoœci

\item [Client] - klasa implementuj¹ca funkcjonalnoœci klienta, tworzy po³¹czenie z serwerem, nas³uchuje nowych wiadomoœci z gniazda oraz zapewnia obs³ugê zdarzeñ interfejsu u¿ytkownika
\item [ClientInfo] - struktura przechowuj¹ca wartoœci parametrów u¿ywanych w protokole Diffiego-Hellmana
\item [Server] - klasa implementuj¹ca funkcjonalnoœci serwera, nas³uchuje nowych wiadomoœci i rozg³asza je do wszystkich pod³¹czonych klientów nak³adaj¹c odpowiednie dla klienta szyfrowanie
\item [SocketListener] - pakiet zawieraj¹cy klasy realizuj¹ce funkcjonalnoœæ szyfrowania wiadomoœci
\item [Variables] - klasa przechowuj¹ca statyczne wartoœci parametrów aplikacji, takich jak adres IP lub port, w celu ³atwiejszego ich przekaywania wewn¹trz aplikacji

\end{description}

\subsection{Nawi¹zanie po³¹czenia}\indent\par

Do nawi¹zania po³¹czenia wykorzystane zosta³y klasy 
\code{Socket}oraz \code{ServerSocket}z pakietu \code{java.net}.
Nawi¹zywanie po³¹czenia w aplikacji nale¿y rozpocz¹æ od uruchomienia serwera. Listing \ref{lst:server_start} przedstawia procedurê uruchomienia. Po uruchomieniu wywo³ywana jest pêtla, która akceptuje kolejne po³¹czenia i tworzy dla nich w¹tki obs³uguj¹ce zdarzenia. W¹tki gromadzone s¹ w kolekcji, aby umo¿liwiæ póŸniejszy dostêp do nich w celu rozg³aszania wiadomoœci. Na ekranie wyœwietlany jest komunikat o adresie IP i porcie, na który powinnny ³¹czyæ siê aplikacje klienckie. 

\begin{lstlisting}[ basicstyle=\small,caption={Metoda nas³uchuj¹ca po³¹czeñ klienckich},label={lst:server_start},language=java]
    public void start(int port) {
        try {
            ServerSocket server = new ServerSocket(port);
            DiffieHellman.initPrimes(DiffieHellman.primeSize);
            display("Waiting for client connections on "
                    + InetAddress.getLocalHost().getHostAddress() + ":"
                    + server.getLocalPort());
            while (true) {

                Socket conn = server.accept();

                ClientThread t = new ClientThread(conn);
                cList.add(t);
                t.start();
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }
		\end{lstlisting}
		
			
W¹tek \code{ClientThread} utworzony po po³¹czeniu z klientem pobiera z utworzonego gniazda strumienie wejœciowy i wyjœciowy, a tak¿e inicjalizuje parametry protoko³u Diffiego-Hellmana. Konstruktor klasy przedstawiono na listingu \ref{lst:clientThread}. W¹tek nas³uchuje wiadomoœci wysy³anych przez uzyskany strumieñ i odpowiada na nie poprzez wywo³anie metody \code{onMessage} interfejsu \code{SocketListener}, której implementacjê przedstawia listing \ref{lst:onmessage} w punkcie \ref{messages}. Pêtla nas³uchuj¹ca przedtawiona zosta³a na listingu \ref{lst:ct_run}.


\begin{lstlisting}[ basicstyle=\small,caption={Konstruktor w¹tku ClientThread},label={lst:clientThread}, language=java]
  ClientThread(Socket socket) {

            try {
                info.setId(++uniqueId);
                info.setSecretB(DiffieHellman.getInitialSecret());
                info.setP(DiffieHellman.generateP());
                info.setG(DiffieHellman.generateG());
                info.setB(DiffieHellman.makeB(info));
                this.socket = socket;
                in = new BufferedReader(new InputStreamReader(
                        socket.getInputStream()));
                out = new PrintWriter(socket.getOutputStream(), true);
                display("User " + info.getId() + " connected from "
                        + socket.getRemoteSocketAddress() + ".");
            } catch (IOException ioe) {
                display("Error creating in/out in ClientThread");
            } catch (NoSuchAlgorithmException | InvalidParameterSpecException e) {
                e.printStackTrace();
            }
        }
\end{lstlisting}


\begin{lstlisting}[ basicstyle=\small,caption={Metoda nas³uchuj¹ca strumienia w w¹tku ClientThread},label={lst:ct_run}, language=java]
  public void run() {
            String line;
            while (true) {
                try {
                    line = in.readLine();
                    System.out.println("Received message:\n\t" + line);
                    onMessage(line);
                } catch (IOException e) {
                    System.out.println(e);
                    break;
                }
            }
        }
\end{lstlisting}
		
		Po stronie klienta po ustanowieniu po³¹czenia równie¿ otwierane s¹ strumienie danych oraz tworzony jest w¹tek nas³uchuj¹cy wiadomoœci wysy³anych przez serwer. Implementacjê tej funkcjonalnoœci przedstawia listing \ref{lst:client}. Po otrzymaniu wiadomoœci wywo³ywana jest metoda \code{onMessage} zaimplementowana w klasie {Client}, pokazana w punkcie \ref{messages}, w listingu \ref{lst:onmessage_client}.
		
		\begin{lstlisting}[ basicstyle=\small,caption={Metody tworz¹ca gniazdo po stronie klienta},label={lst:client}, language=java]

public void startClient(String ip, int port) {
        info = new ClientInfo();
        info.setPort(port);
        info.setSecretA(DiffieHellman.getInitialSecret());
        updateInfo();
        try {
            socket = new Socket(ip.trim(), port);
            in = new BufferedReader(new InputStreamReader(
                    socket.getInputStream()));
            out = new PrintWriter(socket.getOutputStream(), true);
            new ChatListener(this).start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
		
		
private class ChatListener extends Thread {
        SocketListener listener;
        ChatListener(SocketListener listener) {
            this.listener = listener;
        }
				
        @Override
        public void run() {
            send(Key.REQUEST, Value.KEYS);

            final String line[] = new String[1];
            while (true) {
                try {
                    line[0] = in.readLine();
                    System.out.println("Received message:\n\t" + line[0]);
                    Platform.runLater(() -> listener.onMessage(line[0]));
                } catch (IOException e) {
                    e.printStackTrace();

                    return;
                }
            }
        }
    }
		
\end{lstlisting}
		
\subsection{Obs³uga wiadomoœci}\label{messages} \indent \par
Obs³ug¹ wiadomoœci przesy³anych w aplikacji zajmuje siê interfejs \code{SocketListener}. Jego implementacje znajduj¹ siê w klasach \code{Client} oraz \code{ClientThread}. Interfejs posiada jedn¹ metodê \code{onMessage(String json)}, której parametrem jest wiadomoœæ otrzymana ze strumienia. Otrzymany ci¹g znaków interpretowany jest przez klasê \code{JSONObject} z biblioteki \code{org.json}, a nastêpnie na podstawie kluczy znajduj¹cych siê w obiekcie podejmowana jest odpowiednia akcja. Implementacje tej metody w wymienionych klasach przedstawiono poni¿ej.

\subsubsection{Client}

\begin{lstlisting}[ basicstyle=\small,caption={Metoda obs³ugi wiadomoœci w klasie Client},label={lst:onmessage_client}, language=java]
 
    @Override
    public void onMessage(String line) {
        JSONObject json = new JSONObject(line);
        if (json.has(Key.MESSAGE)) {
            String message = json.getString(Key.MESSAGE);
            message = new String(Base64.getDecoder().decode(message),
				StandardCharsets.UTF_8);
            chatWindow.getItems().add(json.get(Key.FROM)+": "+decrypt(message));
        }
        if (json.has(Key.A_KEY)) {

            System.out.println("Client should never receive A value!");
        }
        if (json.has(Key.B_KEY)) {
            info.setB(json.getBigInteger("b"));
            if (info.isReady()) {
                info.setS(DiffieHellman.makeClientSecret(info));
            }
            updateInfo();
        }
        if (json.has(Key.P_KEY)) {

            info.setP(json.getBigInteger("p"));
            info.setG(json.getBigInteger("g"));
            info.setA(DiffieHellman.makeA(info));
            JSONObject aJson = new JSONObject();
            aJson.put(Key.A_KEY, info.getA());
            out.println(aJson.toString());
            out.flush();
            updateInfo();
        }
        if (json.has(Key.ENCRYPTION)) {
            if (info.isReady()) {
                info.setS(DiffieHellman.makeClientSecret(info));
                updateInfo();
            }
        }
    }
\end{lstlisting}

\subsubsection{ClientThread}

\begin{lstlisting}[ basicstyle=\small, caption={Metoda obs³ugi wiadomoœci w klasie ClientThread},label={lst:onmessage}, language=java]
  @Override
public void onMessage(String line) {
	JSONObject json = new JSONObject(line);
	display(line);
	if (json.has(Key.MESSAGE)) {
		String encoded = json.getString(Key.MESSAGE);
		String encrypted = new String(Base64.getDecoder().decode(encoded),
					StandardCharsets.UTF_8);
		String message = decrypt(encrypted);
		String name = json.getString(Key.FROM);
		broadcast(message,name);
	}
   if (json.has(Key.REQUEST)) {
		if (json.getString(Key.REQUEST).equals(Value.KEYS)) {
			JSONObject pgJson = new JSONObject();
			try {
				pgJson.put(Key.P_KEY, DiffieHellman.generateP());
				pgJson.put(Key.G_KEY, DiffieHellman.generateG());
			} catch (NoSuchAlgorithmException |
			InvalidParameterSpecException e) {
				e.printStackTrace();
			}
			sendJson(pgJson.toString(), this);
			try {
				sleep(500);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			JSONObject bJson = new JSONObject();
			bJson.put(Key.B_KEY, info.getB());
			sendJson(bJson.toString(), this);
		}
	}
	if (json.has(Key.A_KEY)) {
		info.setA(json.getBigInteger("a"));
		if (info.isReady()) {
			info.setS(DiffieHellman.makeServerSecret(info));
			display(info.toString());
		}
	}
	if (json.has(Key.B_KEY)) {
		System.out.println("Server should never receive B value!");
	}
	if (json.has(Key.P_KEY)) {
		System.out.println("Server should never receive p or g value!");
	}
	if (json.has(Key.ENCRYPTION)) {
		String en = json.getString(Key.ENCRYPTION);
		if (en.equals(Value.CAESAR) || en.equals(Value.NONE) || 
			en.equals(Value.XOR))
			info.setEncryption(en);
	}
}
\end{lstlisting}

\subsection{Szyfrowanie}\indent \par
W aplikacji zaimplementowane zosta³y dwie metody szyfrowania wiadomoœci: szyfrowanie XOR oraz szyfr cezara. Implementacje metod szyfruj¹cych przedstawione zosta³y na listingach \ref{lst:xor} oraz \ref{lst:cezar} znajduj¹cych siê poni¿ej. Ze wzglêdu na odwracalnoœæ operacji \code{xor} szyfrowanie i deszyfrowanie wiadomoœci mo¿na wykonaæ przy uzyciu tej samej metody.

\begin{lstlisting}[ basicstyle=\small, caption={Szyfrowanie XOR},label={lst:xor}, language=java]
 public class Xor {

    public static byte[] encrypt(String string, BigInteger secret) {
        byte[] a = string.getBytes();
        byte[] key = secret.toByteArray();
        byte[] out = new byte[a.length];
        for (int i = 0; i < a.length; i++) {
            out[i] = (byte) (a[i] ^ key[key.length-1]);
        }
        return out;
    }
}
\end{lstlisting}



\begin{lstlisting}[ basicstyle=\small, caption={Szyfr cezara },label={lst:cezar}, language=java]
public class Caesar {
    public static String encrypt(String string, BigInteger shift) {
        StringBuilder encrypted = new StringBuilder();

        for (char c : string.toCharArray()) {
            int ascii = (int) c;
            ascii += (shift.mod(BigInteger.valueOf(26))).intValue();
            if (ascii > (Character.isLowerCase(c) ? 'z' : 'Z')) ascii -= 26;
            encrypted.append((char) ascii);
        }
        return encrypted.toString();
    }
		
    public static String decrypt(String string, BigInteger shift) {

        StringBuilder decrypted = new StringBuilder();
        for (char c : string.toCharArray()) {
            int ascii = (int) c;
            ascii -= (shift.mod(BigInteger.valueOf(26))).intValue(); if (ascii < (Character.isLowerCase(c) ? 'a' : 'A')) ascii += 26;
            decrypted.append((char) ascii);
        }
        return decrypted.toString();
    }
}
\end{lstlisting}

\label{sec:introduction}
\section{Podsumowanie}\indent \par
Przygotowana aplikacja spe³nia wymagania projektu:
\begin{itemize}
\item Aplikacja poprawnie ³¹czy siê przez sieæ z wykorzystaniem gniazd,
\item Zaimplmenetowany zosta³ bezpieczny protokó³ wymiany kluczy Diffiego-Hellmana,
\item Zaimplementowane zosta³y dwie metody szyfrowania,
\item Poprawnie obs³ugiwany jest zadany protokó³ komunikacyjny. Aplikacja poprawnie komunikuje siê z innymi implementacjami przygotowanymi przez uczestników laboratorium,
\item Metody szyfrowania mo¿na zmieniæ przed wys³aniem ka¿dej wiadomoœci.
\end{itemize}

\end{document}